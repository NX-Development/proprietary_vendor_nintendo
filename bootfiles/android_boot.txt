scrrev=7

# Set r2p params
setenv hekate_id SWANDR
setenv r2p_reboot_action bootloader
setenv r2p_param1 0
setenv r2p_param2 0

# Set SoC/SKU info.
if test ${t210b01} = 1; then setenv plat_info T210B01; else setenv plat_info T210; fi
if   test ${sku} = 0; then setenv hw_sku icosa
elif test ${sku} = 1; then setenv hw_sku iowa
elif test ${sku} = 2; then setenv hw_sku hoag
elif test ${sku} = 3; then setenv hw_sku aula; fi

# Print platform info.
echo PLAT:   ${plat_info} SKU: ${hw_sku}
echo Serial: ${device_serial}
echo BT MAC: ${device_bt_mac}
echo WF MAC: ${device_wifi_mac}

# SD is always bootfile mmc
setenv sdmmc_idx 1

setenv mmc_idx 1

# Check if eMMC boot is enabled
if test -n ${emmc}; then
    setenv mmc_idx 0
    echo eMMC boot enabled!
# Keep overlay check for compat
elif test -n ${overlays}; then
    for ov in ${overlays}; do
        if test "${ov}" = "tegra210-icosa_emmc-overlay"; then
            setenv mmc_idx 0
            setenv emmc 1
            echo eMMC boot enabled!
            echo \\e eMMC boot overlay no longer needed--switch to just setting emmc=1 in uenv.txt
        fi
    done
else
    echo SD boot enabled!
fi

mmc dev $mmc_idx

# fastboot setup for our GPT layout
setenv fastboot_partition_alias_boot LNX
setenv fastboot_partition_alias_system APP
setenv fastboot_partition_alias_userdata UDA
setenv fastboot_partition_alias_cache CAC
setenv fastboot_partition_alias_recovery SOS
setenv fastboot_partition_alias_dtb DTB

# load fastboot first so 'fastboot continue' works
gpio input 191 || fastboot 0

# store main MMC serial number to use as device serial
mmc info serial#

# generate a uboot version we can assert against in recovery
setexpr ver_simple gsub "U-Boot (.*) \\(.*\\)" "\\1-rev$scrrev" "$ver"

# find root partition and convert to decimal
part number mmc $mmc_idx APP app_part_num
setexpr app_part_num_dec gsub "^0x1$" 1 $app_part_num
setexpr app_part_num_dec gsub "^0x2$" 2 $app_part_num
setexpr app_part_num_dec gsub "^0x3$" 3 $app_part_num
setexpr app_part_num_dec gsub "^0x4$" 4 $app_part_num
setexpr app_part_num_dec gsub "^0x5$" 5 $app_part_num
setexpr app_part_num_dec gsub "^0x6$" 6 $app_part_num
setexpr app_part_num_dec gsub "^0x7$" 7 $app_part_num
setexpr app_part_num_dec gsub "^0x8$" 8 $app_part_num
setexpr app_part_num_dec gsub "^0x9$" 9 $app_part_num
setexpr app_part_num_dec gsub "^0xa$" 10 $app_part_num
setexpr app_part_num_dec gsub "^0xb$" 11 $app_part_num
setexpr app_part_num_dec gsub "^0xc$" 12 $app_part_num
setexpr app_part_num_dec gsub "^0xd$" 13 $app_part_num
setexpr app_part_num_dec gsub "^0xe$" 14 $app_part_num
setexpr app_part_num_dec gsub "^0xf$" 15 $app_part_num
setexpr app_part_num_dec gsub "^0x10$" 16 $app_part_num

host_mac_addr=0xff

# load mac address info file
if fatload mmc ${sdmmc_idx}:1 0x90000000 switchroot/joycon_mac.bin; then
    if itest.b *0x90000000 == 0x01; then
        echo Left JoyCon is available
        host_mac_addr=0x90000007
    else
        echo \\e Left JoyCon pairing info is not available!
    fi

    if itest.b *0x9000001d == 0x02; then
        echo Right JoyCon is available
        host_mac_addr=0x90000024
    else
        echo \\e Right JoyCon pairing info is not available!
    fi
fi

if itest $host_mac_addr == 0xff; then
    echo No JoyCons available

    # write to a known good location
    mw.q 0x90000000 ${serial#} 1

    # write crc32 of value at offset 0x3
    crc32 0x90000000 8 0x90000003

    # write nintendo prefix
    mw.b 0x90000000 0x98 1
    mw.b 0x90000001 0xE8 1
    mw.b 0x90000002 0xFA 1

    # use this to generate mac
    host_mac_addr=0x90000000
fi

bt_mac=""
sep=""
for i in 0 1 2 3 4 5 ; do
    setexpr x $host_mac_addr + $i
    setexpr.b b *$x
    if itest $b <= f; then
        # There is no way to have leading zeros, so do this hack
        bt_mac="$bt_mac${sep}0$b"
    else
        bt_mac="$bt_mac$sep$b"
    fi
    sep=":"
done

# FIXME after hekate gets wifi mac reading
setexpr.b last_byte *0x90000005
if itest $last_byte == 0xFF; then
    # wrap around case
    setexpr wifi_mac gsub "(.*:.*:.*:.*:.*:).*" "\\100" $bt_mac
else
    setexpr.b wb $last_byte + 1
    if itest $wb <= f; then
        setexpr wifi_mac gsub "(.*:.*:.*:.*:.*:).*" "\\10$wb" $bt_mac
    else
        setexpr wifi_mac gsub "(.*:.*:.*:.*:.*:).*" "\\1$wb" $bt_mac
    fi
fi

# Set extra bootargs to kill console and set default loglevel
setenv bootargs_extra "console=null loglevel=5"

# load dtb
part start mmc $mmc_idx DTB dtb_part_start
part size mmc $mmc_idx DTB dtb_part_size

mmc read $fdt_addr_r $dtb_part_start $dtb_part_size

fdt addr $fdt_addr_r

# Load overlays based on uenv.txt 
if test -n ${overlays}; then
    for ov in ${overlays}; do
        echo overlaying ${ov}...
        fdt resize 8192

        if fatload mmc ${sdmmc_idx}:1 0x8f000000 switchroot/overlays/${ov}.dtbo && fdt apply 0x8f000000; then
            echo Successfully loaded ${ov}.dtbo...
            if test "${ov}" = "tegra210-UART-B-overlay"; then
                # Override bootargs_extra for extra logging with UART overlay
                setenv bootargs_extra "no_console_suspend androidboot.console=ttyS1 console=ttyS1,115200,8n1 loglevel=8"
            fi
        else
            # Error on failure to apply
            echo \\e failed to overlay ${ov}!; sleep 5; reset
        fi
    done
fi

# Patch DT on eMMC boot
if test -n ${emmc}; then
    fdt set /sdhci@700b0600 status okay
    setenv bootargs_extra "${bootargs_extra} androidboot.boot_devices=sdhci-tegra.3"
else
    setenv bootargs_extra "${bootargs_extra} androidboot.boot_devices=sdhci-tegra.0"
fi

# insert mac address dtb node
fdt set /chosen nvidia,wifi-mac ${wifi_mac}
fdt set /chosen nvidia,bluetooth-mac ${bt_mac}

# Prepare display panel id from Nyx.
cp.b 0xED838002 0xED838001 0x1
mw.b 0xED838002 0x0 0x1

# Get display panel handle.
if   test ${display_id} = f20;  then echo Display is INN 6.2; fdt get value DHANDLE /host1x/dsi/panel-i-720p-6-2 phandle
elif test ${display_id} = f30;  then echo Display is AUO 6.2; fdt get value DHANDLE /host1x/dsi/panel-a-720p-6-2 phandle
elif test ${display_id} = 10;   then echo Display is JDI 6.2; fdt get value DHANDLE /host1x/dsi/panel-j-720p-6-2 phandle
elif test ${display_id} = 1020; then echo Display is INN 5.5; fdt get value DHANDLE /host1x/dsi/panel-i-720p-5-5 phandle
elif test ${display_id} = 1030; then echo Display is AUO 5.5; fdt get value DHANDLE /host1x/dsi/panel-a-720p-5-5 phandle
elif test ${display_id} = 1040; then echo Display is SHP 5.5; fdt get value DHANDLE /host1x/dsi/panel-sh-720p-5-5 phandle
elif test ${display_id} = 2050; then echo Display is SAM 7.0
elif test ${sku} = 3;      then echo Display is SAM 7.0
else echoe Unknown Display ID: ${display_id}!; fi

# Set new active display panel handle.
if test -n ${DHANDLE}; then echo Setting Display panel; fdt resize 8192; fdt set /host1x@50000000/dsi nvidia,active-panel <$DHANDLE>; fi

# Set common bootargs
setenv bootargs_path "init=/init nvdec_enabled=0 usbcore.autosuspend=-1 log_buf_len=4M androidboot.bootloader=${ver_simple} androidboot.hardware=nx \
                      androidboot.hardware.sku=${hw_sku} androidboot.selinux=permissive androidboot.serialno=${serial#} androidboot.modem=none \
                      pcie_aspm=off vpr_resize pmc_r2p.enabled=1 pmc_r2p.action=${r2p_reboot_action} pmc_r2p.entry_id=${hekate_id} \
                      pmc_r2p.param1=${r2p_param1} pmc_r2p.param1=${r2p_param2} tegra_fbmem=0x800000@0xf5a00000"

# gpio 190 = VOL_UP, 191 = VOL_DOWN
if gpio input 190 && test ${recovery} = "0"; then
    # normal boot
    part start mmc ${mmc_idx} LNX root_part_start
    part size mmc ${mmc_idx} LNX root_part_size

    setenv bootargs "${bootargs_extra} ${bootargs_path} skip_initramfs ro rootwait root=/dev/mmcblk0p${app_part_num_dec} firmware_class.path=/vendor/firmware \
    bluetooth.disable_ertm=1 "
 
    mmc read 0x98000000 $root_part_start $root_part_size

    bootm 0x98000000 0x98000000 0x8d000000
else
    # recovery
    part start mmc ${mmc_idx} SOS root_part_start
    part size mmc ${mmc_idx} SOS root_part_size

    setenv bootargs "${bootargs_extra} ${bootargs_path} firmware_class.path=/etc/firmware "
        
    mmc read 0x98000000 $root_part_start $root_part_size

    bootm 0x98000000 0x98000000 0x8d000000
fi

echo \\e Failed to launch kernel!
echo \\e  
echo \\e Rebooting in 10s...

sleep 10
reset
